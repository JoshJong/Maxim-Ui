"use strict";
var fs = require('fs'),
    path = require('path'),
    cssom = require('cssom'),
    CssCleaner = require('clean-css'),
    async = require('async');

class Media{
    constructor(file){
        this.file = file;
        this.data = {};
    }
    init(){
        let stat = fs.statSync(this.file);

        if(stat && stat.isFile()){
            //文件相对路径
            var r_path = path.dirname(this.file),
                fName = path.basename(this.file).replace(path.extname(this.file),'');
            //读取文件内容
            var data = fs.readFileSync(this.file).toString();
            //文件进行处理，删除注释，调整相对路径
            var content = new CssCleaner({
                keepSpecialComments : 0,
                aggressiveMerging : false,
                restructuring : false,//禁止结构合并
                keepBreaks : true,
                relativeTo : r_path,
                root : '',//根目录设计值为空串保证合并的正确
                rebase : true//相对目录进行重写
            }).minify(data).styles;

            //cssom对象
            var om = cssom.parse(content);
            
            //分析并处理cssom对象
            var medias = this.chargeOM(om,fName);

            //处理media的各个节点，进行样式处理/雪碧图合并
            this.chargeMedias(medias);
        }else{
            
        }
    }
    /**
     * 根据cssom生成的对象，将样式以media区段进行划分
     * */
    chargeOM(om , fName){
        //分析后的结果数组
        let ret = [],
            defaultMedia = {
                description : 'default',
                rules : [],
                name : fName
            };
        if(om && om.cssRules.length > 0){
            //第一层样式对象
            let rootRules = om.cssRules,
                len = rootRules.length,
                j = 1,
                imgPrefix = fName + '-media';
            //遍历整个规则集合，分析出media对应的样式对象
            for(let i = 0 ; i < len ; i++){
                let item = rootRules[i];
                /**
                 * item.type = 1 ，css style ，样式对象
                 * item.type = 4 ，media style ，media对象
                 * */
                switch (item.type){
                    case 1 :
                        defaultMedia.rules.push({
                            selectorText : item.selectorText,
                            CSSStyleDeclaration : item.CSSStyleDeclaration
                        });
                        break;
                    case 4 :
                        ret.push({
                            description : item.media[0],
                            rules : item.cssRules,
                            name : imgPrefix + j
                        });
                        j++;
                        break;
                    default : break;
                }
            }
            //如果有默认样式，即非media query中的样式代码，当然大部分情况下都是有的，我们这里把整个情景统一起来
            if(defaultMedia.rules.length > 0){
                for(let i = ret.length ; i > 0 ; i--){
                    ret[i] = ret[i-1];
                }
                ret[0] = defaultMedia;
            }
            return ret;
        }
    }
    /**
     * 处理medias的内容并生成相应的雪碧图/样式
     * */
    chargeMedias(medias){
        let _this = this,
            count = medias.length,
            tasks = [];
        for(let i = 0 ; i < count ; i++){
            tasks.push(_this.chargeMedia(medias[i]));
        }
        //处理不同的任务
        async.parallel(tasks,(err,results) => {
            console.log(results);
        });
    }
    /**
     * 处理单个media
     * */
    chargeMedia(media){
        return function (cb) {
            //开始处理单个的media

            //返回处理结果到列表
            cb(null,{
                name : media.name
            });
        }
    }
}

module.exports = Media;