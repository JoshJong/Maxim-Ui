var CssSliceImg = require('css-slice-imgs');
var path = require('path');
var fs = require('fs');
var async = require('async');
var Spritesmith = require('spritesmith');
var CssCleaner = require('clean-css');
var common = require('./common.js');
var os = require('os');
function Sprite(){}
Sprite.prototype = {
    _getOwner : function(){
        var host = os.hostname().toLowerCase();
        var i = host.lastIndexOf('-');
        var rtx = host.substring(0,i);
        var nowTime = new Date();
        return common.getCurrentPlat().enter + '#MAXIM{content:"' + rtx.substr(0,2) + rtx.substr(rtx.length-1,1) + nowTime.getFullYear() + (nowTime.getMonth()+1 >= 10 ? nowTime.getMonth()+1 : '0' + (nowTime.getMonth()+1)) + nowTime.getDate() + nowTime.getHours() + nowTime.getMinutes() + nowTime.getSeconds() + '"}';
    },
    sprite : function(cssFiles,config,callback){
        //强制在代码后面加上分隔符
        config.destPath = config.destPath[config.destPath.length -1] === path.sep ? config.destPath : config.destPath + path.sep;
        config.localPath = config.localPath[config.localPath.length -1] === path.sep ? config.localPath : config.localPath + path.sep;

        //判断是单个文件还是一个文件数组
        if(typeof cssFiles === 'string'){
            var tmp = cssFiles;
            cssFiles = [];
            cssFiles.push(tmp);
        }
        //获取文件个数
        var count = cssFiles.length;
        var results = [];
        var funcs = [];
        //时间戳
        var timestampSprite = config.spriteNameSwitch === 'true' ? '-'+config.spriteName : '';
        var timestampCss = config.cssNameSwitch === 'true' ? '-'+config.cssName : '';
        //加在样式文件的尾部
        var cssTail = this._getOwner();

        //多个样式文件之间是可并行的
        for(var i = 0 ; i < count ;i++){
            //将对应的样式处理函数添加到任务列表
            funcs.push(_charge(i));
        }
        //并行处理文件
        async.parallel(funcs,function(err,rets){
            //遍历结果集，组装到一个一维数组中
            for(var i = 0 ; i < rets.length ;i++){
                for(var j = 0; j < rets[i].length ; j++){
                    results.push(rets[i][j]);
                }
            }
            callback(results);
        });
        //处理样式文件数组中的第n个样式
        function _charge(n){
            return function (cb) {
                var m = n;
                //获取样式文件的结果集
                new CssSliceImg().getImages(cssFiles[m],{},function(result){
                    //保存背景图抽取后的模块执行结果
                    var r = result;
                    //这个将用来存储png合并、jpg合并、样式处理的结果
                    var ret = [];
                    //判断样式文件处理是否成功，这一步很重要，如果样式处理失败了则后面不用继续做了
                    if(r.status === false){
                        ret.push(r);
                        //直接回调
                        cb(null,ret);
                    }else {
                        //雪碧图路径生成规则：获取slice图片引用地址，提取sprite的与路径中img目录同级下
                        var destFile = r.cssFile.replace(config.localPath, config.destPath);
                        //给文件名打上时间戳
                        destFile = path.dirname(destFile) + path.sep + r.basename + timestampCss + '.css';
                        //文件后缀名
                        var pngPostFix = '.png';
                        var pngPostFix2x = '@2x.png';
                        var jpgPostFix = '.jpg';
                        //png雪碧图名称
                        var pngSpriteName = r.basename + timestampSprite + pngPostFix;
                        var pngSpriteName2x = r.basename + timestampSprite + pngPostFix2x;
                        //jpg雪碧图名称
                        var jpgSpriteName = r.basename + timestampSprite + jpgPostFix;
                        //path.sep根据系统来自动改变值为\\ 或 \/，雪碧图目录跟样式文件同级
                        var destSpritePath = path.dirname(destFile) + path.sep + 'sprite' + path.sep;
                        //需要创建雪碧图时才创建该目录
                        var cssPath = path.dirname(destFile);
                        //源文件操作css相对目录
                        var relativePath = path.dirname(cssFiles[m]);
                        //直接判断雪碧图路径是否存在，不存在则直接创建，避免在下面的环节中重复判断
                        if (fs.existsSync(destSpritePath) ===  false) {
                            //createPath是一个同步方法
                            common.createPath(destSpritePath, fs);
                        }
                        //目标雪碧图及样式文件的地址
                        var targetPngSprite = destSpritePath + pngSpriteName;
                        var targetPngSprite2x = destSpritePath + pngSpriteName2x;

                        var targetJpgSprite = destSpritePath + jpgSpriteName;
                        var targetCss = destFile;
                        /**将雪碧图的合并分为3种情况
                         * 0、没有图片合并的需求
                         * 1、全部都是单倍图，且单倍图无对应的双倍图（纯pc且不考虑Retina适配场景）
                         * 2、全部都是多倍图（目前以2倍图作为主要处理情景），完全要考虑Retina适配的场景，且不需再生成单倍图
                         * 3、全部都是单倍图，且部分或全部由对应的双倍图，考虑普通场景及Retina场景
                         * */
                        var sceneType = confirmScene(r);
                        switch (sceneType){
                            case 0 : (function(){
                                /**
                                 * 只做样式处理
                                 * */
                                //文件buffer准备
                                var buffer = result.buffer;
                                //将样式文件写到目标位置
                                fs.writeFile(destFile,new CssCleaner({
                                        keepSpecialComments : 0,
                                        keepBreaks : false,
                                        aggressiveMerging : false,
                                        restructuring : false,//避免属性合并带来的结构重组，这里禁止进行属性合并，且更改原有结构
                                        relativeTo :relativePath,//这个一定要用源css文件所在的目录
                                        //root : cssPath,//对相对路径进行处理时，这个设置为空字符串则只是相对于当前文件所在目录来进行路径resolve
                                        rebase : true//对图片路径进行处理
                                    }).minify(buffer).styles + cssTail,function(err){
                                    if(err){
                                        ret.push({
                                            //如果是windows下的斜杠则进行转换
                                            fName : destFile.replace(config.destPath,'').replace(/\\/g,'\/'),
                                            status : false,
                                            message : err.message
                                        });
                                    }else{
                                        ret.push({
                                            fName : destFile.replace(config.destPath,'').replace(/\\/g,'\/'),
                                            status : true
                                        });
                                    }
                                    cb(null,ret);
                                });
                            })();
                                break;
                            case 1 : (function(){
                                /**
                                 * 只做单倍图合并和样式处理
                                 * */
                                async.waterfall([
                                    //合并多倍图
                                    function(callback){
                                        Spritesmith.run({
                                            src: r.pngPathes,
                                            //雪碧图上图片之间的间距
                                            padding: 2
                                        }, function handleResult(err,spriteResult) {
                                            if (err) {
                                                console.log(err.message);
                                                ret.push({
                                                    fName: targetPngSprite.replace(config.destPath, '').replace(/\\/g, '\/'),
                                                    status: false,
                                                    message: err.message
                                                });
                                                //如果出错，则直接告诉下 一个任务上一环节出问题
                                                callback(null, {
                                                    taskStatus: false
                                                });
                                            } else {
                                                fs.writeFile(targetPngSprite, spriteResult.image, function (err) {
                                                    if (err) {
                                                        //png图片合并
                                                        ret.push({
                                                            fName: targetPngSprite.replace(config.destPath, '').replace(/\\/g, '\/'),
                                                            status: false,
                                                            message: err.message
                                                        });
                                                        //如果出错，则直接告诉下 一个任务上一环节出问题
                                                        ret.push({
                                                            fName: targetPngSprite.replace(config.destPath, '').replace(/\\/g, '\/'),
                                                            status: false,
                                                            message : err.message
                                                        });
                                                        callback(null, {
                                                            taskStatus: false
                                                        });
                                                    } else {
                                                        //png图片合并
                                                        ret.push({
                                                            fName: targetPngSprite.replace(config.destPath, '').replace(/\\/g, '\/'),
                                                            status: true
                                                        });
                                                        //传递合并结果给下一环节
                                                        callback(null,spriteResult);
                                                    }
                                                });
                                            }
                                        });
                                    },
                                    //处理样式
                                    function(preveResult,callback){
                                        if(preveResult.taskStatus === false){
                                            ret.push({
                                                fName : targetCss.replace(config.destPath, '').replace(/\\/g, '\/'),
                                                status : false,
                                                message : 'css file operated failed because of sprite error'
                                            });
                                            //说明上一环节处理出错
                                            callback(null,{
                                                taskStatus : false
                                            });
                                        }else{
                                            var coordinates = preveResult.coordinates;
                                            var rect = preveResult.properties;//Object with metadata about spritesheet {width, height}
                                            var rules = r.rules;
                                            var content = r.fileContent;
                                            var maps = r.pngMaps;
                                            var cssContent = generateCss(content,rules,maps,coordinates,rect,pngSpriteName,1);
                                            fs.writeFile(targetCss,cssContent,function(err){
                                                if(err){
                                                    ret.push({
                                                        fName : targetCss.replace(config.destPath, '').replace(/\\/g, '\/'),
                                                        status : false,
                                                        message : err.message
                                                    });
                                                }else{
                                                    ret.push({
                                                        fName : targetCss.replace(config.destPath, '').replace(/\\/g, '\/'),
                                                        status : true
                                                    });
                                                }
                                                //直接告诉下一个任务本次任务ok
                                                callback(null,{
                                                    taskStatus : true
                                                });
                                            });
                                        }
                                    }
                                ],function(err,waterfallResult){
                                    cb(null,ret);
                                });
                            })();
                                break;
                            case 2 : (function(){
                                /**
                                 * 只做多倍图合并和样式处理
                                 * */
                                async.waterfall([
                                    //合并多倍图
                                    function(callback){
                                        Spritesmith.run({
                                            src: r.pngPathes2x,
                                            //雪碧图上图片之间的间距
                                            padding: 2
                                        }, function handleResult(err,spriteResult) {
                                            if (err) {
                                                ret.push({
                                                    fName: targetPngSprite2x.replace(config.destPath, '').replace(/\\/g, '\/'),
                                                    status: false,
                                                    message: err.message
                                                });
                                                //如果出错，则直接告诉下 一个任务上一环节出问题
                                                callback(null, {
                                                    taskStatus: false
                                                });
                                            } else {
                                                fs.writeFile(targetPngSprite2x, spriteResult.image, function (err) {
                                                    if (err) {
                                                        //png图片合并
                                                        ret.push({
                                                            fName: targetPngSprite2x.replace(config.destPath, '').replace(/\\/g, '\/'),
                                                            status: false,
                                                            message: err.message
                                                        });
                                                        //如果出错，则直接告诉下 一个任务上一环节出问题
                                                        callback(null, {
                                                            taskStatus: false
                                                        });
                                                    } else {
                                                        //png图片合并
                                                        ret.push({
                                                            fName: targetPngSprite2x.replace(config.destPath, '').replace(/\\/g, '\/'),
                                                            status: true
                                                        });
                                                        //传递合并结果给下一环节
                                                        callback(null,spriteResult);
                                                    }
                                                });
                                            }
                                        });
                                    },
                                    //处理样式
                                    function(preveResult,callback){
                                        if(preveResult.status === false){
                                            //说明上一环节处理出错
                                            callback(null,{
                                                taskStatus : false
                                            });
                                        }else{
                                            /*
                                             "/home/todd/github/spritesmith/docs/fork.png": {
                                             "x": 0,
                                             "y": 0,
                                             "width": 32,
                                             "height": 32
                                             }
                                             * */
                                            var coordinates = preveResult.coordinates;
                                            var rect = preveResult.properties;//Object with metadata about spritesheet {width, height}
                                            var rules = r.rules;
                                            var content = r.fileContent;
                                            var maps = r.pngMaps2x;
                                            var cssContent = generateCss(content,rules,maps,coordinates,rect,pngSpriteName2x,2);
                                            fs.writeFile(targetCss,cssContent,function(err){
                                                if(err){
                                                    ret.push({
                                                        fName : targetCss.replace(config.destPath, '').replace(/\\/g, '\/'),
                                                        status : false,
                                                        message : err.message
                                                    });
                                                }else{
                                                    ret.push({
                                                        fName : targetCss.replace(config.destPath, '').replace(/\\/g, '\/'),
                                                        status : true
                                                    });
                                                }
                                                //直接告诉下一个任务本次任务ok
                                                callback(null,{
                                                    taskStatus : true
                                                });
                                            });
                                        }
                                    }
                                ],function(err,waterfallResult){
                                    cb(null,ret);
                                });
                            })();
                                break;
                            case 3 : (function(){
                                //单倍图合并、多倍图合并和样式处理
                            })();
                                break;
                        }
                    }

                });
            }
        }
        /**
         * content ：初步处理过的样式文件的文本内容
         * rules ：cssom处理后获得的style的规则
         * maps : 样式选择器=》图片绝对地址
         * coordinates ：雪碧图合并后的坐标及单个图标的宽高
         * rect ：雪碧图的宽高
         * ratio ：雪碧图倍率 默认为1
         * */
        function generateCss(content,rules,maps,coordinates,rect,spriteName,ratio){
            //默认为1的比率
            var spriteRatio = ratio || 1;
            if(spriteRatio > 1){
                //合并的全部是多倍图
                //console.log(rules);
                //console.log(coordinates);
                //console.log(rect);
                //遍历样式规则数组
                for(var i = 0 ; i < rules.length ; i++){
                    var selector = rules[i].selector;
                    var position = coordinates[maps[selector]];
                    var selRule = selector + '{';
                    //判断是否是需要合并雪碧图的规则时
                    if(rules[i].isSprite === true) {
                        //这时要替换规则下的background-image、background-size、background-position
                        rules[i].rules['background-image'] = 'url(sprite/' + spriteName + ')';
                        rules[i].rules['background-size'] = rect.width / spriteRatio + 'px ' + rect.height / spriteRatio + 'px';
                        rules[i].rules['background-position'] = -position.x / spriteRatio + 'px ' + -position.y / spriteRatio + 'px';

                        for(var p in rules[i].rules){
                            selRule += p + ':' + rules[i].rules[p] + ';'
                        }
                        selRule += '}';
                        //构造选择器最近花括号匹配的正则表达式，因为[]是正则中的表达式符号，所以要进行转义处理
                        /**
                         *这里有2个地方一定要注意注意：
                         * 1、类选择器中如果有[]方括号对属性进行设置，一定要对它们进行转义，因为方括号是正则的函数部分
                         * 2、由于会出现一个选择器跟其他选择器混合在一起并且在最后面，这样就会被匹配到，所以一定要匹配行首的选择器打头的
                         * （2中要注意匹配行首的话一定要开启多行匹配模式 即 mg）
                         * */
                        var c_selector = selector.replace(/\^/g,'\\^').replace(/\[/g,'\\[').replace(/\]/g,'\\]');
                        var reg = new RegExp('\^' + c_selector + '\{[^\}]*\}','mg');
                        var match = content.match(reg);

                        //判断是否匹配到内容
                        if(match == null){
                            console.log(reg);
                        }
                        //console.log(match);
                        //对匹配到的内容进行替换
                        content = content.replace(match[0],selRule);
                    }
                }
            }else if(spriteRatio == 1) {
                //单倍图合并
                for (var i = 0; i < rules.length; i++) {
                    var selector = rules[i].selector;
                    //如果选择器不存在则不处理下面的
                    if(selector === undefined){
                        break;
                    }
                    var position = coordinates[maps[selector]];

                    var selRule = selector + '{';
                    //这时要替换规则下的background-image、background-size、background-position
                    rules[i].rules['background-image'] = 'url(sprite/' + spriteName + ')';
                    rules[i].rules['background-size'] = rect.width / spriteRatio + 'px ' + rect.height / spriteRatio + 'px';
                    rules[i].rules['background-position'] = -position.x / spriteRatio + 'px ' + -position.y / spriteRatio + 'px';
                    //组装其他属性的值到样式中
                    for (var p in rules[i].rules) {
                        selRule += p + ':' + rules[i].rules[p] + ';'
                    }
                    selRule += '}';

                    //构造选择器最近花括号匹配的正则表达式，因为[]是正则中的表达式符号，所以要进行转义处理
                    var c_selector = selector.replace(/\^/g,'\\^').replace(/\[/g,'\\[').replace(/\]/g,'\\]');
                    var reg = new RegExp('\^' + c_selector + '\{[^\}]*\}','mg');
                    //console.log(reg);
                    var match = content.match(reg);

                    //判断是否匹配到内容
                    if(match == null || match.length <= 0){
                        console.log(reg);
                        return;
                    }
                    //对匹配到的内容进行替换
                    content = content.replace(match[0],selRule);
                }
            }
            //去除字符串的换行
            content = content.split(common.getCurrentPlat().enter).join('');
            return content + cssTail;
        }
        function confirmScene(r){
            /**
             * flag 对应上面的描述，有3个场景，这里返回值域为[0-3]，其中添加了一个0的状态=》无雪碧图合并的场景
             * */
            //默认是第一种场景
            var flag = 0;
            //获取结果中的单倍图和多倍图的绝对路径数组
            var pngPathes = r.pngPathes,
                pngPathes2x = r.pngPathes2x;
            if(pngPathes2x.length > 0 && pngPathes.length <= 0){
                //全部都是2倍图
                flag = 2;
            }else if(pngPathes.length > 0){
                //有单倍图合并的需求，则构造对应的多倍图的绝对地址，因为要求不允许在样式文件中同时写单倍图和多倍图，因此这里会把pngPathes2x清空
                pngPathes2x = [];
                var count = pngPathes.length;
                for(var i = 0 ; i < count ; i++){
                    //判断单倍图对应的多倍图是否存在，这里使用同步的方法
                    var fname = pngPathes[i].replace('.png','@2x.png');
                    if(fs.exists(fname) === true){
                        //存在的话则将该多倍图的图片压入多倍图图片地址的数组中
                        pngPathes2x.push(fname);
                    }
                }
                if(pngPathes2x.length <= 0){
                    //说明没有对应的2倍图合并需求，全部都是一倍图，返回1
                    flag = 1;
                }else{
                    //说明还有对应的2倍图需要合并，这里返回3
                    flag = 3;
                }
            }else{
                //既没有单倍图也没有多倍图的合并需求，只有样式处理
                flag = 0;
            }
            return flag;
        }
    }
};
module.exports = Sprite;