var CssSliceImg = require('css-slice-imgs');
var path = require('path');
var fs = require('fs');
var async = require('async');
var Spritesmith = require('spritesmith');
var CssCleaner = require('clean-css');
var common = require('./common.js');
var os = require('os');
var mover = require('./mover.js');
var csslint = require('./verify.js');

function Sprite(){}
Sprite.prototype = {
    _getOwner : function(){
        var host = os.hostname().toLowerCase();
        var i = host.lastIndexOf('-');
        var rtx = host.substring(0,i);
        var nowTime = new Date();
        return common.getCurrentPlat().enter
            + '#MAXIM{content:"'
            + rtx.substr(0,2)
            + rtx.substr(rtx.length-1,1)
            + nowTime.getFullYear()
            + (nowTime.getMonth() + 1 >= 10 ? nowTime.getMonth() + 1 : '0' + (nowTime.getMonth() + 1))
            + (nowTime.getDate() > 10 ? nowTime.getDate() : '0' + nowTime.getDate())
            + (nowTime.getHours() > 10 ? nowTime.getHours() : '0' + nowTime.getHours())
            + (nowTime.getMinutes() > 10 ? nowTime.getMinutes() : '0' + nowTime.getMinutes())
            + (nowTime.getSeconds() > 10 ? nowTime.getSeconds() : '0' + nowTime.getSeconds())
            + '"}';
    },
    sprite : function(cssFiles,config,callback){
        //强制在代码后面加上分隔符
        config.destPath = config.destPath[config.destPath.length -1] === path.sep ? config.destPath : config.destPath + path.sep;
        config.localPath = config.localPath[config.localPath.length -1] === path.sep ? config.localPath : config.localPath + path.sep;

        //判断是单个文件还是一个文件数组
        if(typeof cssFiles === 'string'){
            var tmp = cssFiles;
            cssFiles = [];
            cssFiles.push(tmp);
        }
        //获取文件个数
        var count = cssFiles.length;
        var results = [];
        var funcs = [];
        //时间戳
        var timestampSprite = config.spriteNameSwitch === 'true' ? '-'+config.spriteName : '';
        var timestampCss = config.cssNameSwitch === 'true' ? '-'+config.cssName : '';
        //加在样式文件的尾部
        var cssTail = this._getOwner();

        //多个样式文件之间是可并行的
        for(var i = 0 ; i < count ;i++){
            //将对应的样式处理函数添加到任务列表
            funcs.push(_charge(i));
        }
        //并行处理文件
        async.parallel(funcs,function(err,rets){
            //遍历结果集，组装到一个一维数组中
            for(var i = 0 ; i < rets.length ;i++){
                for(var j = 0; j < rets[i].length ; j++){
                    results.push(rets[i][j]);
                }
            }
            callback(results);
        });
        //处理样式文件数组中的第n个样式
        function _charge(n){
            return function (cb) {
                var m = n,
                    vResult;
                //这里加上文件校验
                vResult = csslint.verifyFile(cssFiles[m]);
                if(vResult.status == false){
                    //文件校验失败，返回失败结果集
                    cb(null,[{
                        fName : cssFiles[m].replace(config.localPath,'').replace(/\\/g,'\/'),
                        status : false,
                        message : vResult.message
                    }]);
                    return;
                }
                //获取样式文件的结果集
                new CssSliceImg().getImages(cssFiles[m],{},function(result){
                    //保存背景图抽取后的模块执行结果
                    var r = result;
                    //这个将用来存储png合并、jpg合并、样式处理的结果
                    var ret = [];
                    //判断样式文件处理是否成功，这一步很重要，如果样式处理失败了则后面不用继续做了
                    if(r.status === false){
                        ret.push(r);
                        //直接回调
                        cb(null,ret);
                    }else {
                        //雪碧图路径生成规则：获取slice图片引用地址，提取sprite的与路径中img目录同级下
                        var destFile = r.cssFile.replace(config.localPath, config.destPath);
                        //给文件名打上时间戳
                        destFile = path.dirname(destFile) + path.sep + r.basename + timestampCss + '.css';
                        //path.sep根据系统来自动改变值为\\ 或 \/，雪碧图目录跟样式文件同级
                        var destSpritePath = path.dirname(destFile) + path.sep + 'sprite' + path.sep;
                        //源文件操作css相对目录
                        var relativePath = path.dirname(cssFiles[m]);
                        //直接判断雪碧图路径是否存在，不存在则直接创建，避免在下面的环节中重复判断
                        if (fs.existsSync(destSpritePath) ===  false) {
                            //createPath是一个同步方法
                            common.createPath(destSpritePath, fs);
                        }
                        //目标样式文件的地址
                        var targetCss = destFile;
                        /**将雪碧图的合并分为3种情况
                         * 0、没有图片合并的需求
                         * 1、全部都是单倍图，且单倍图无对应的双倍图（纯pc且不考虑Retina适配场景）
                         * 2、全部都是多倍图（目前以2倍图作为主要处理情景），完全要考虑Retina适配的场景，且不需再生成单倍图
                         * 3、全部都是单倍图，且部分或全部由对应的双倍图，考虑普通场景及Retina场景
                         * */
                        var sceneType = confirmScene(r);
                        //获取分组后的结果
                        var pngs_property = sceneType === 2 ?  'pngPathes2x' : 'pngPathes';
                        var groups = groupFolder(r[pngs_property]);
                        //文件buffer准备
                        var buffer = r.buffer;
                        //根据图片归类，合并雪碧图
                        if(groups.count <= 0){
                            //没有合并图片的需求
                            //将样式文件写到目标位置
                            fs.writeFile(destFile,new CssCleaner({
                                    keepSpecialComments : 0,
                                    keepBreaks : false,
                                    aggressiveMerging : false,
                                    restructuring : false,//避免属性合并带来的结构重组，这里禁止进行属性合并，且更改原有结构
                                    relativeTo :relativePath,//这个一定要用源css文件所在的目录
                                    //root : cssPath,//对相对路径进行处理时，这个设置为空字符串则只是相对于当前文件所在目录来进行路径resolve
                                    rebase : true//对图片路径进行处理
                                }).minify(buffer).styles + cssTail,function(err){
                                if(err){
                                    ret.push({
                                        //如果是windows下的斜杠则进行转换
                                        fName : destFile.replace(config.destPath,'').replace(/\\/g,'\/'),
                                        status : false,
                                        message : err.message
                                    });
                                }else{
                                    ret.push({
                                        fName : destFile.replace(config.destPath,'').replace(/\\/g,'\/'),
                                        status : true
                                    });
                                }
                                //同步资源
                                if(r.uploadImages.length > 0 && config.resourceSyncSwitch && config.resourceSyncSwitch === 'true'){
                                    //设置打版本的开关为开
                                    config.timeStampSwitch = true;
                                    new mover().copy(r.uploadImages,config,function(data){
                                        ret = ret.concat(data);
                                        cb(null,ret);
                                    });
                                }else{
                                    cb(null,ret);
                                }
                            });
                        }else{
                            /**
                             * 遍历groups来合并雪碧图
                             * props ：为分组后的对象数组
                             * sprite_funcs ：是待完成的合并任务
                             * ratio : 合并图片的倍率
                             * padding ：小图的空隙
                             * */
                            var props = [],sprite_funcs = [],ratio = 1,padding = 1;
                            for( var p in groups){
                                if(p !== 'count'){
                                    //不需要分到目录下的以样式名称为文件名
                                    if(p === 'maxim_default'){
                                        props.push({
                                            name : path.basename(r.cssFile).replace('.css',''),
                                            files : groups[p]
                                        });
                                    }else{
                                        props.push({
                                            name : p,
                                            files : groups[p]
                                        });
                                    }
                                };
                            }
                            //根据场景类型来设置ratio和padding
                            switch (sceneType){
                                case 2 :
                                    ratio = 2;
                                    padding = 2;
                                    break;
                                default :
                                    ratio = 1;
                                    padding = 1;
                                    break;
                            }
                            for( var i = 0 ; i < props.length ; i++){
                                sprite_funcs.push(_folder(r,ret,relativePath,destSpritePath,buffer,props,i,ratio));
                            }
                            //处理所有的图片合并
                            async.waterfall(sprite_funcs,function(err,groupCss){
                                if(err){
                                    //错误处理
                                }else{
                                    //去掉代码中的换行
                                    if(groupCss.status === false){
                                        //处理结果有错误
                                        ret.push({
                                            fName : targetCss.replace(config.destPath,'').replace(/\\/g,'\/'),
                                            status : false,
                                            message : groupCss.message
                                        });
                                        cb(null,ret);
                                    }else{
                                        var cssFileContent = groupCss.cssContent.split(common.getCurrentPlat().enter).join('');
                                        // var cssFileContent = groupCss.cssContent;
                                        cssFileContent += cssTail;
                                        //生成最终的样式文件，并返回结果
                                        fs.writeFile(targetCss,cssFileContent,function(err){
                                            if(err){
                                                ret.push({
                                                    fName : targetCss.replace(config.destPath,'').replace(/\\/g,'\/'),
                                                    status : false,
                                                    message : err.message
                                                });
                                            }else{
                                                ret.push({
                                                    fName : targetCss.replace(config.destPath,'').replace(/\\/g,'\/'),
                                                    status : true
                                                });
                                            }
                                            //拷贝资源
                                            if(r.uploadImages.length > 0 && config.resourceSyncSwitch && config.resourceSyncSwitch === 'true'){
                                                //设置打版本的开关为开
                                                config.timeStampSwitch = true;
                                                new mover().copy(r.uploadImages,config,function(data){
                                                    ret = ret.concat(data);
                                                    cb(null,ret);
                                                });
                                            }else{
                                                cb(null,ret);
                                            }
                                        });
                                    }

                                }
                            });
                        }
                    }
                });
            }
        }
        /**
         * r : 图片提取模块处理的结果
         * relativePath : 样式文件中资源参照的目录
         * destSpritePath : 目标雪碧图目录
         * buffer : 样式文件的二进制串
         * groups : 分组后的文件目录名、目录下的图片地址数组对象（数组）
         * n ：数组的第n项索引
         * ratio : 合并的图的倍率，默认为1
         * */
        function _folder(r,ret,relativePath,destSpritePath,buffer,groups,n,ratio){
            //间距默认为1
            var padding = ratio || 1;
            var taskData = groups[n];
            if(n == 0){
                //第一个函数没有之前传入的数据，返回的时候要特殊处理，同时读取样式文件内容
                var cssContent = new CssCleaner({
                    keepSpecialComments : 0,
                    keepBreaks : true,
                    aggressiveMerging : false,
                    restructuring : false,//避免属性合并带来的结构重组，这里禁止进行属性合并，且更改原有结构
                    relativeTo :relativePath,//这个一定要用源css文件所在的目录
                    rebase : true//对图片路径进行处理
                }).minify(buffer).styles;
                return function(cb){
                    spriteImages(r,ret,destSpritePath,{
                        status : true,
                        cssContent : cssContent
                    },taskData,cb,padding);
                };
            }else{
                //返回非第一个函数的形式，会带有之前的函数处理的结果
                return function(prevResult , cb){
                    //处理之前传过来的结果
                    spriteImages(r,ret,destSpritePath,prevResult,taskData,cb,padding);
                };
            }
            /**
             * r ；图片抽取中的结果集
             * ret ：结果集数组
             * destSpritePath : 目标雪碧图目录
             * cssContent : 样式内容字符串
             * taskData ：指定目录的目录名、目录下的图片地址
             * cb ：回调函数
             * padding ：图片之间的间隙
             * */
            function spriteImages(r,ret,destSpritePath , prevData,taskData,cb,padding){
                if(prevData.status === false){
                    //当上一个任务出错时，直接跳过告诉下一个任务前面有问题，告诉下一个任务，上个任务出错
                    cb(null,{
                        status : false,
                        message : prevData.message
                    });
                }
                //处理后传递给下一个任务的数据，这里一般是本任务的处理结果标志（是否成功）、处理后的样式文件串
                var passData = prevData.cssContent;
                //目标雪碧图的地址，目前只考虑png图片
                var fName = destSpritePath + taskData.name + timestampSprite + '.png';
                //合并对应的雪碧图
                Spritesmith.run({
                    src: taskData.files,
                    //雪碧图上图片之间的间距
                    padding: padding
                } , function(err , images){
                    var imgs = images;
                    if(err){
                        ret.push({
                            fName : fName.replace(config.destPath,'').replace(/\\/g,'\/'),
                            status : false,
                            message : err.message
                        });
                        //告诉下一个任务，本任务出错
                        cb(null,{
                            status : false,
                            message : err.message
                        });
                    }else{
                        //写雪碧图文件、处理css字符串
                        fs.writeFile( fName , imgs.image ,function(err){
                            if(err){
                                cb(null,{
                                    status : false,
                                    message : err.message
                                });
                            }else{
                                //处理样式内容串
                                //console.log(r.rules, r[padding == 1 ? 'pngpngPathes' : 'pngpngPathes2x'],images.coordinates,images.originalProperties,path.basename(fName),padding);
                                //console.log(prevData);
                                //根据倍率来构建相应的key值
                                var path_property = padding == 1 ? 'pngPathes' : 'pngPathes' + padding + 'x';
                                var map_property = padding == 1 ? 'pngMaps' : 'pngMaps' + padding + 'x';
                                //var ss = r[path_property];
                                passData = generateCss(prevData.cssContent, r.rules, r[map_property],imgs.coordinates,imgs.properties,path.basename(fName),padding);
                                //添加到结果集中
                                ret.push({
                                    fName : fName.replace(config.destPath,'').replace(/\\/g,'\/'),
                                    status : true
                                });
                                //向下一步任务提交处理结果
                                cb(null,{
                                    status : true,
                                    cssContent : passData
                                });
                            }
                        });
                    }
                });
            }
        }
        /**
         * content ：初步处理过的样式文件的文本内容
         * rules ：cssom处理后获得的style的规则
         * maps : 样式选择器=》图片绝对地址
         * coordinates ：雪碧图合并后的坐标及单个图标的宽高
         * rect ：雪碧图的宽高
         * ratio ：雪碧图倍率 默认为1
         * */
        function generateCss(content,rules,maps,coordinates,rect,spriteName,ratio){
            //默认为1的比率
            var spriteRatio = ratio || 1;
            if(spriteRatio > 1){
                //合并的全部是多倍图
                //遍历样式规则数组
                for(var i = 0 ; i < rules.length ; i++){
                    //图片是否进行合并过处理的标志
                    if(rules[i].isSprite === false){
                        break;
                    }
                    var selector = rules[i].selector;
                    var position = coordinates[maps[selector]];
                    var selRule = selector + '{';
                    //判断是否是需要合并雪碧图的规则时
                    if(rules[i].isSprite === true) {
                        //这时要替换规则下的background-image、background-size、background-position
                        rules[i].rules['background-image'] = 'url(sprite/' + spriteName + ')';
                        //当为1倍图合并时，不加background-size
                        rules[i].rules['background-size'] = rect.width / spriteRatio + 'px ' + rect.height / spriteRatio + 'px';
                        rules[i].rules['background-position'] = -position.x / spriteRatio + 'px ' + -position.y / spriteRatio + 'px';
                        for(var p in rules[i].rules){
                            selRule += p + ':' + rules[i].rules[p] + ';'
                        }
                        selRule += '}';
                        //构造选择器最近花括号匹配的正则表达式，因为[]是正则中的表达式符号，所以要进行转义处理
                        /**
                         *这里有2个地方一定要注意注意：
                         * 1、类选择器中如果有[]方括号对属性进行设置，一定要对它们进行转义，因为方括号是正则的函数部分
                         * 2、+的转义
                         * 3、由于会出现一个选择器跟其他选择器混合在一起并且在最后面，这样就会被匹配到，所以一定要匹配行首的选择器打头的
                         * （3中要注意匹配行首的话一定要开启多行匹配模式 即 mg）
                         * */
                        var c_selector = selector.replace(/\^/g,'\\^').replace(/\[/g,'\\[').replace(/\]/g,'\\]').replace(/\+/g,'\\+').replace(/\(/g,'\\(').replace(/\)/g,'\\)');
                        var reg = new RegExp('\^' + c_selector + '\{[^\}]*\}','mg');
                        var match = content.match(reg);

                        //判断是否匹配到内容
                        if(match == null){
                            console.log(reg);
                        }
                        //console.log(match);
                        //对匹配到的内容进行替换
                        content = content.replace(match[0],selRule);
                    }
                }
            }else if(spriteRatio == 1) {
                //单倍图合并
                for (var i = 0; i < rules.length; i++) {
                    //图片是否进行合并过处理的标志，处理过的直接跳过
                    if(rules[i].isSprite === false){
                        continue;
                    }
                    var selector = rules[i].selector;
                    //如果选择器不存在则不处理下面的
                    if(selector === undefined){
                        break;
                    }
                    //这里是遍历整个数组，会出现分组时部分数据为空，下面最好加上判断
                    var position = coordinates[maps[selector]];

                    if(position === undefined){
                        break;
                    }
                    var selRule = selector + '{';
                    //这时要替换规则下的background-image、background-size、background-position
                    rules[i].rules['background-image'] = 'url(sprite/' + spriteName + ')';
                    rules[i].rules['background-position'] = -position.x / spriteRatio + 'px ' + -position.y / spriteRatio + 'px';
                    //组装其他属性的值到样式中
                    for (var p in rules[i].rules) {
                        selRule += p + ':' + rules[i].rules[p] + ';'
                    }
                    selRule += '}';

                    //构造选择器最近花括号匹配的正则表达式，因为[]是正则中的表达式符号，所以要进行转义处理
                    var c_selector = selector.replace(/\^/g,'\\^').replace(/\[/g,'\\[').replace(/\]/g,'\\]').replace(/\+/g,'\\+').replace(/\(/g,'\\(').replace(/\)/g,'\\)');
                    var reg = new RegExp('\^' + c_selector + '\{[^\}]*\}','mg');
                    //console.log(reg);
                    var match = content.match(reg);

                    //判断是否匹配到内容
                    if(match == null || match.length <= 0){
                        console.log(reg);
                        return;
                    }
                    //对匹配到的内容进行替换
                    content = content.replace(match[0],selRule);
                    rules[i].isSprite = false;
                }
            }
            //这里的功能有个变化，不能去掉换行符,以为后面的匹配是在保留换行的基础之上的
            //content = content.split(common.getCurrentPlat().enter).join('');
            return content;
        }
        function confirmScene(r){
            /**
             * flag 对应上面的描述，有3个场景，这里返回值域为[0-3]，其中添加了一个0的状态=》无雪碧图合并的场景
             * */
            //默认是第一种场景
            var flag = 0;
            //获取结果中的单倍图和多倍图的绝对路径数组
            var pngPathes = r.pngPathes,
                pngPathes2x = r.pngPathes2x;
            if(pngPathes2x.length > 0 && pngPathes.length <= 0){
                //全部都是2倍图
                flag = 2;
            }else if(pngPathes.length > 0){
                //有单倍图合并的需求，则构造对应的多倍图的绝对地址，因为要求不允许在样式文件中同时写单倍图和多倍图，因此这里会把pngPathes2x清空
                pngPathes2x = [];
                var count = pngPathes.length;
                for(var i = 0 ; i < count ; i++){
                    //判断单倍图对应的多倍图是否存在，这里使用同步的方法
                    var fname = pngPathes[i].replace('.png','@2x.png');
                    if(fs.exists(fname) === true){
                        //存在的话则将该多倍图的图片压入多倍图图片地址的数组中
                        pngPathes2x.push(fname);
                    }
                }
                if(pngPathes2x.length <= 0){
                    //说明没有对应的2倍图合并需求，全部都是一倍图，返回1
                    flag = 1;
                }else{
                    //说明还有对应的2倍图需要合并，这里返回3
                    flag = 3;
                }
            }else{
                //既没有单倍图也没有多倍图的合并需求，只有样式处理
                flag = 0;
            }
            return flag;
        }
        /**
         * feature : 用于匹配目录名的特征值，默认为one-,one_
         * imgs : 图片绝对地址数组
         *  */
        function groupFolder(imgs,feature){
            var folders = {
                count : 0
            };
            //默认特征值为one
            var folder_feature = feature || 'one';
            //图片匹配
            var regex = null;
            //windows系统和其他操作系统的路径分隔符做兼容
            if(common.getPlatName() === 'windows'){
                regex = /(slice\\one[_|\-](.+))(?=\\)/g;
            }else{
                regex = /(slice\/one[_|\-](.+))(?=\/)/g;
            }
            var imgs_length = imgs.length;
            var tmp = null,folder_name = '';
            //遍历图片数组，对图片进行特征值分类
            for( var i = 0 ; i < imgs_length ; i++){
                tmp = imgs[i].match(regex);
                //分隔符前面切记要添加反斜杠
                var re = new RegExp('slice\\' + path.sep + 'one[_|\-]','g');
                if(tmp !== null && tmp.length > 0){
                    folder_name = tmp[0].replace(re,'');
                    if(folders[folder_name] === undefined){
                        folders[folder_name] = [];
                        folders.count++;
                    }
                    folders[folder_name].push(imgs[i]);
                }else{
                    //否则都加到maxim_default中
                    if(folders['maxim_default'] === undefined){
                        folders['maxim_default'] = [];
                        folders.count++;
                    }
                    folders.maxim_default.push(imgs[i]);
                }
            }
            return folders;
        }
    }
};
module.exports = Sprite;