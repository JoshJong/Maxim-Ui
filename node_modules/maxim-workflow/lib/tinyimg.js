/**
 * Created by owenhong on 2015/11/17.
 */

var fs = require("fs");
var request = require('request');
var tinify = require("tinify");
var path = require('path');
var Common = require("./common.js");

var TinyImg = function() {
    this.request = function(file, opt, cb) {
        var self = this;

        var options = opt || "";

        var token = new Buffer('api:' + options.tinyApi).toString('base64');

        return {
            file: file,

            upload: function(cb) {
                var file = this.file;

                request.post({
                    url: 'https://api.tinypng.com/shrink',
                    proxy: options.proxy,
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'Authorization': 'Basic ' + token
                    },
                    strictSSL: false,
                    body: file
                }, function(err, res, body) {

                    if(res === undefined){
                        cb(err, info);
                    }

                    var data,
                        info = {
                            url: false,
                            count: res.headers['compression-count'] || 0
                        };

                    if(err) {
                        err = new Error('Upload failed for ' + file.relative + ' with error: ' + err.message);

                    } else if(body) {
                        try {
                            data = JSON.parse(body);
                        } catch(e) {
                            err = new Error('Upload response JSON parse failed, invalid data returned from API. Failed with message: ' + e.message);
                        }

                        if(!err) {
                            if(data.error) err = this.handler(data); else if(data.output.url) {
                                info.url = data.output.url;
                            } else err = new Error('Invalid TinyPNG response object returned for ' + file.relative);
                        }
                    } else {
                        err = new Error('No content returned from TinyPNG API for' + file.relative);
                    }

                    cb(err, info);

                }.bind(this));
            },

            download: function(url, cb) {
                request.get({
                    url: url,
                    proxy: options.proxy,
                    encoding: null
                }, function(err, res, body) {
                    err = err ? new Error('Download failed for ' + url + ' with error: ' + err.message) : false;
                    cb(err, new Buffer(body));
                });
            },

            handler: function(data) {
                var errs = {
                    Unauthorized: 'The request was not authorized with a valid API key',
                    InputMissing: 'The file that was uploaded is empty or no data was posted',
                    BadSignature: 'The file was not recognized as a PNG or JPEG file. It may be corrupted or it is a different file type',
                    UnsupportedFile: 'The file was recognized as a PNG or JPEG file, but is not supported',
                    DecodeError: 'The file had a valid PNG or JPEG signature, but could not be decoded, most likely corrupt',
                    TooManyRequests: 'Your monthly upload limit has been exceeded',
                    InternalServerError: 'An internal error occurred during compression'
                };

                return data.error + ': ' + ((data.error in errs) ? errs[data.error] : data.message || 'unknown') + ' for ' + file.relative;
            },

            get: function(cb) {
                var self = this,
                    file = this.file;

                self.upload(function(err, data) {
                    if(err) return cb(err, file);

                    self.download(data.url, function(err, data) {
                        if(err) return cb(err, file);

                        cb(false, data);
                    });
                });

                return this;
            }
        };
    };
}

var TinyPng = new TinyImg();

function Tiny(){}
Tiny.prototype.TinyImg = function(imgs,config,globalConfig,callback){

    //tiny api set
    tinify.key = globalConfig.tinyApi;

    //处理config中路径的配置如果不以\结尾，则要加上
    config.localPath = config.localPath[config.localPath.length-1] === '\\' ? config.localPath : config.localPath + '\\';
    config.destPath = config.destPath[config.destPath.length-1] === '\\' ? config.destPath : config.destPath + '\\';

    //获取文件名
    var f_name = path.basename(imgs[0]);

    //将源文件的根目录替换为目标目录的根目录
    var dest = imgs[0].replace(config.localPath,config.destPath);

    //获取文件的父目录
    var f_Path = dest.replace(f_name,'');

    //因为node不支持多级目录同时创建，因此得调用自己的api去逐级建立目录
    Common.createPath(f_Path,fs);

    var count = imgs.length;
    var index = count;
    var results = []

    var compress = function(i){
        //获取每个文件名
        var file_name = path.basename(imgs[i]);
        var $fName = imgs[i].replace(config.localPath, '').replace(config.destPath, '').replace(/\\/g, '\/');

        var tinySuccess = function(err,resultData){
            if(err) {
                console.log("bbb");
                console.log(err);

                results.push({
                    fName: $fName,
                    status: false,
                    message: JSON.stringify(err)
                });

                index--;
                if (index <= 0) {
                    callback(results);
                }
            } else {
                console.log("c");

                //压缩后的图片输出
                fs.writeFile(f_Path + file_name, resultData, function (err) {
                    if (err){
                        results.push({
                            fName: $fName,
                            status: false,
                            message: err
                        });

                        index--;
                        if (index <= 0) {
                            callback(results);
                        }
                    }else{
                        results.push({
                            fName: $fName,
                            status: true,
                            message: 'Img compress success!'
                        });

                        console.log('Img compress success !');
                        index--;
                        if (index <= 0) {
                            callback(results);
                        }
                    }
                });
            }
        }

        if(config.proxy ==""){
            fs.readFile(imgs[i], function (err, sourceData) {
                if (err) {
                    results.push({
                        fName: $fName,
                        status: false,
                        message: err.message
                    });
                    console.log("a1");
                } else {
                    console.log("b1");
                    tinify.fromBuffer(sourceData).toBuffer(function (err, resultData) {
                        tinySuccess(err, resultData);
                    });
                }
            });
        }else {
            fs.readFile(imgs[i], function (err, sourceData) {
                if (err) {
                    results.push({
                        fName: $fName,
                        status: false,
                        message: err.message
                    });

                    index--;
                    if (index <= 0) {
                        callback(results);
                    }

                    console.log("a2");
                } else {
                    console.log("b2");
                    TinyPng.request(sourceData, globalConfig).get(function (err, resultData) {

                        console.log(err);

                        tinySuccess(err, resultData);
                    });
                }
            });
        }
    }

    for(var i = 0;i < count;i++){
        compress(i);
    }
}


module.exports = Tiny;